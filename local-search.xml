<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解 Chrome DevTools</title>
    <link href="/2023/03/16/DevTools/"/>
    <url>/2023/03/16/DevTools/</url>
    
    <content type="html"><![CDATA[<h2 id="Chrome-DevTools"><a href="#Chrome-DevTools" class="headerlink" title="Chrome DevTools"></a>Chrome DevTools</h2><p>Chrome DevTools是Google Chrome浏览器的一组内置Web开发工具，用于调试、优化和测试Web应用程序。<br>Chrome DevTools [官方文档] (<a href="https://developers.google.com/web/tools/chrome-devtools?hl=zh-cn">https://developers.google.com/web/tools/chrome-devtools?hl=zh-cn</a>)<br>Chrome DevTools 是辅助开发者进行 Web 开发的重要调试工具，DevTools 是 Chromium 的一部分，可以作为独立项目被 Electron 等容器集成。DevTools 主要分为四部分：</p><ul><li>Frontend：调试器前端，默认由 Chromium 内核层集成</li><li>Backend：调试器后端，Chromium、V8 或 Node.js</li><li>Protocol：调试协议</li><li>Message Channels：消息通道，包括：Embedder Channel、WebSocket Channel、Chrome Extensions Channel、USB&#x2F;ADB Channel<img src="/2023/03/16/DevTools/%E4%BA%A4%E4%BA%92%E9%80%BB%E8%BE%91.png" class="" title="交互逻辑"></li></ul><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>Chrome DevTools包括多个面板，如Elements（元素）、Console（控制台）、Sources（源代码）、Network（网络）和Performance（性能）等。每个面板提供了各种功能</p><table><thead><tr><th align="center">面板</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Elements面板</td><td align="center">用于查看和编辑页面上的HTML、CSS和JavaScript。</td></tr><tr><td align="center">Console面板</td><td align="center">提供了一个交互式JavaScript控制台，可以执行JavaScript代码并查看日志和错误消息。</td></tr><tr><td align="center">Sources面板</td><td align="center">用于调试JavaScript代码，可以设置断点、单步执行和监视变量等。</td></tr><tr><td align="center">Network面板</td><td align="center">用于查看HTTP请求和响应，以及网页加载性能分析。</td></tr><tr><td align="center">Performance面板</td><td align="center">提供了一些有用的工具，例如跟踪重绘和回流、分析页面加载时间等。</td></tr></tbody></table><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>Chrome DevTools的作用是帮助开发人员诊断和解决Web应用程序中的问题，例如：</p><ul><li>调试JavaScript代码：可以使用DevTools的调试器功能在运行中的JavaScript代码中设置断点、单步执行、监视变量等。</li><li>优化网页性能：可以使用Network和Performance面板分析网页的加载性能，识别慢速请求和瓶颈，以及评估页面的渲染速度。</li><li>检查网页结构：可以使用Elements面板查看和编辑页面的HTML、CSS和JavaScript，查找错误和潜在的性能问题。</li><li>测试响应式设计：可以使用Device Mode功能测试网页在不同设备上的外观和功能。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Chrome DevTools通过Chrome浏览器提供的开发者API与浏览器进行通信。开发者API允许DevTools与浏览器交互，以获取有关页面结构、资源和性能的信息，并对浏览器进行控制和调试。DevTools使用Chrome浏览器内置的WebKit引擎来解析和渲染网页，并提供各种功能和面板来帮助开发人员调试和优化Web应用程序。</p><h2 id="Chrome-Extension"><a href="#Chrome-Extension" class="headerlink" title="Chrome Extension"></a>Chrome Extension</h2><h3 id="和Plug-in对比"><a href="#和Plug-in对比" class="headerlink" title="和Plug-in对比"></a>和Plug-in对比</h3><p>我们经常说的 Chrome “插件”，其实不是真正意义上的 Chrome Plug-in，一般是指 Chrome Extension(简称“拓展”)。</p><ul><li>扩展（Extension），指的是通过调用 Chrome 提供的 Chrome API 来扩展浏览器功能的一种组件，工作在浏览器层面，使用 HTML + Javascript 语言开发。</li><li>插件（Plug-in），指的是通过调用 Webkit 内核 NPAPI&#x2F;PPAPI 来扩展内核功能的一种组件，工作在内核层面，理论上可以用任何一种生成本地二进制程序的语言开发，比如 C&#x2F;C++、Delphi 等。比如 Flash player 插件，就属于这种类型。一般在网页中用 <code>&lt;object&gt;</code> 或者 <code>&lt;embed&gt;</code> 标签声明的部分，就要靠插件来渲染。</li></ul><ol><li><p>功能不同：Chrome Extension 是一种基于Web技术的浏览器扩展，可以在浏览器上添加新的功能和服务，如广告拦截、翻译、代理等；而 Plug-in 是一种用于扩展浏览器功能的二进制程序，通常用于媒体播放、PDF查看等功能。</p></li><li><p>应用场景不同：Chrome Extension 更适合于需要修改或扩展浏览器功能的场景，例如添加新的工具栏、弹出式窗口或网页注入等；而 Plug-in 更适合于需要在浏览器中运行特定类型文件的场景，例如音视频播放、图像处理、PDF查看等。</p></li><li><p>编写方式不同：Chrome Extension 通常使用HTML、CSS、JavaScript等Web技术编写，并可以访问浏览器的API和资源；而 Plug-in 通常需要使用特定的编程语言和API，例如C++、NPAPI等。</p></li><li><p>安全性不同：由于 Chrome Extension 是基于Web技术开发的，因此其运行在沙箱环境中，可以保护用户的隐私和安全；而 Plug-in 由于是二进制程序，存在一定的安全风险，可能会导致漏洞和恶意攻击。</p></li></ol><h3 id="Chrome-Extension-的组件构成"><a href="#Chrome-Extension-的组件构成" class="headerlink" title="Chrome Extension 的组件构成"></a>Chrome Extension 的组件构成</h3><ol><li><p>manifest.json：是 Extension 的元数据，定义了 Extension 的基本信息、权限、文件路径等，是 Extension 的配置文件。</p></li><li><p>Background Scripts：是在 Extension 启动时运行的后台脚本，可以监听浏览器事件、处理网络请求等，常用于实现后台任务和消息通信。</p></li><li><p>Content Scripts：是在 Web 页面中运行的 JavaScript 脚本，可以修改页面的 DOM 结构、响应用户交互等，常用于实现页面注入和页面操作。</p></li><li><p>Popup Views：是 Extension 的弹出窗口，可以显示 Extension 的功能和信息，常用于实现用户界面和交互。</p></li><li><p>Options Pages：是 Extension 的设置页面，可以允许用户自定义 Extension 的功能和选项。</p></li><li><p>Browser Actions 和 Page Actions：是 Extension 的按钮和图标，可以显示在浏览器工具栏或地址栏中，常用于实现用户快速操作和反馈。</p></li></ol><h3 id="Chrome-Extension-的架构图"><a href="#Chrome-Extension-的架构图" class="headerlink" title="Chrome Extension 的架构图"></a>Chrome Extension 的架构图</h3><img src="/2023/03/16/DevTools/chromeExtension%E6%9E%B6%E6%9E%84.png" class="" title="架构图片"><h3 id="Chrome-Extension-分类"><a href="#Chrome-Extension-分类" class="headerlink" title="Chrome Extension 分类"></a>Chrome Extension 分类</h3><p>Chrome 拓展的 JS 主要可以分为这 5 类：injected script、content-script、popup js、background js 和 devtools js</p><table><thead><tr><th>JS 种类</th><th>可访问的 API</th><th>DOM 访问情况</th><th>JS 访问情况</th><th>直接跨域</th></tr></thead><tbody><tr><td>injected script</td><td>和普通 JS 无任何差别，不能访问任何扩展 API</td><td>可以访问</td><td>可以访问</td><td>不可以</td></tr><tr><td>content script</td><td>只能访问 extension、runtime 等部分 API</td><td>可以访问</td><td>不可以</td><td>不可以</td></tr><tr><td>popup js</td><td>可访问绝大部分 API，除了 devtools 系列</td><td>不可直接访问</td><td>不可以</td><td>可以</td></tr><tr><td>background js</td><td>可访问绝大部分 API，除了 devtools 系列</td><td>不可直接访问</td><td>不可以</td><td>可以</td></tr><tr><td>devtools js</td><td>只能访问 devtools、extension、runtime 等部分 API</td><td>可以访问</td><td>可以访问</td><td>不可以</td></tr></tbody></table><h2 id="Chrome-DevTools-Extension"><a href="#Chrome-DevTools-Extension" class="headerlink" title="Chrome DevTools Extension"></a>Chrome DevTools Extension</h2><p>Chrome DevTools Extensions 是基于 Chrome 开发者工具（DevTools）的扩展，可以为开发者工具添加更多的功能和工具。开发者可以通过 Chrome DevTools Extensions 扩展开发者工具的面板、侧边栏、代码片段等组件，为开发者提供更多的工具和功能。</p><p>目前主流小程序平台针对小程序特有的技术特征，基于 Chrome DevTools Extensions 进行扩展及改造，赋能小程序开发的各种调试能力。</p><ol><li>DevTools 面板（DevTools panel）：扩展添加的面板，可以与开发者工具中的元素检查器、控制台等组件集成，为开发者提供更多的工具和功能；</li><li>DevTools 侧边栏（DevTools sidebar）：扩展添加的侧边栏，可以包含自定义的工具和面板，为开发者提供更多的导航和展示功能；</li><li>Content script：与网页内容交互的脚本，可以向页面注入代码、修改页面内容等；</li><li>Background page：后台页面，可以处理扩展的后台任务、事件等；</li><li>Popup 页面（Popup page）：弹出窗口页面，可以与用户交互，提供扩展的快捷操作和功能；</li><li>Options 页面（Options page）：选项设置页面，可以让用户自定义扩展的行为和功能。</li></ol><img src="/2023/03/16/DevTools/chromeDevToolsExtension%E6%9E%B6%E6%9E%84.png" class="" title="架构图片"><h2 id="Chrome-DevTools-protocol"><a href="#Chrome-DevTools-protocol" class="headerlink" title="Chrome DevTools protocol"></a>Chrome DevTools protocol</h2><p>Chrome DevTools protocol 是一种基于 JSON 的协议，用于远程控制和调试 Chrome 浏览器或 Chromium 内核的应用程序。通过该协议，可以让开发者在运行的 Chrome 实例中获取应用程序的状态、调试应用程序、模拟用户操作等。</p><p>Chrome DevTools protocol 是基于 WebSocket 实现的，可以通过 WebSocket 连接来和 Chrome 浏览器进行通信。开发者可以通过发送特定的 JSON 消息，来控制浏览器进行特定的操作，如打开一个新的标签页、导航到指定的 URL、获取页面的 DOM 结构等。</p><p>该协议把操作划分为不同的域(domain)，比如 DOM、Debugger、Network、Console 和 Timeline 等，可以理解为 DevTools 中的不同功能模块。</p><p>每个域(domain)定义了它所支持的 command 和它所产生的 event。每个 command 包含 request 和 response 两部分，request 部分指定所要进行的操作以及操作说要的参数，response 部分表明操作状态，成功或失败。command 和 event 中可能涉及到非基本数据类型，在 domain 中被归为 Type，比如：’frameId’: <code>&lt;FrameId&gt;</code>，其中 FrameId 为非基本数据类型。</p><p>基于 Chrome Debugging Protocol 的 Client 端的库有很多，其中比较常用的有：</p><ol><li>Chrome Remote Interface：官方提供的 Node.js 库，支持对 Chrome 浏览器或 Chromium 内核进行远程调试。</li><li>Puppeteer：由 Google 开发的一个 Node.js 库，支持对 Chrome 或 Chromium 进行自动化控制和测试。</li><li>pychrome：Python 的一个 Chrome Debugging Protocol 客户端库，可以通过 Python 脚本来控制 Chrome 浏览器或 Chromium。</li><li>chromedp：Golang 的一个 Chrome Debugging Protocol 客户端库，可以通过 Golang 代码来控制 Chrome 浏览器或 Chromium。</li><li>ChromeDevTools.jl：Julia 的一个 Chrome Debugging Protocol 客户端库，可以通过 Julia 代码来控制 Chrome 浏览器或 Chromium。</li></ol><h2 id="搞清楚的问题为啥可以进行远程调试"><a href="#搞清楚的问题为啥可以进行远程调试" class="headerlink" title="搞清楚的问题为啥可以进行远程调试"></a>搞清楚的问题为啥可以进行远程调试</h2><p>什么是远程调试？远程调试可以让您从自己的开发计算机上检查 Android 设备上运行的页面，当然开发本地的页面也可以通过远程调试的方式实现。</p><img src="/2023/03/16/DevTools/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95.png" class="" title="远程调试"><p>远程调试的交互流程</p><img src="/2023/03/16/DevTools/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%B5%81%E7%A8%8B.png" class="" title="远程调试流程"><p>真机调试流程总览</p><img src="/2023/03/16/DevTools/%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95.png" class="" title="真机调试"><h3 id="Chrome-Inspect如何映射移动设备的webview视图"><a href="#Chrome-Inspect如何映射移动设备的webview视图" class="headerlink" title="Chrome Inspect如何映射移动设备的webview视图"></a>Chrome Inspect如何映射移动设备的webview视图</h3><ol><li><p>在移动设备上打开要调试的 Web 应用程序，并确保设备和计算机在同一局域网中。</p></li><li><p>在移动设备上启用开发者选项，并开启 USB 调试模式。</p></li><li><p>将移动设备通过 USB 连接到计算机上，并在计算机上打开 Chrome 浏览器。</p></li><li><p>在 Chrome 地址栏中输入 chrome:&#x2F;&#x2F;inspect，并回车。</p></li><li><p>在页面上找到“设备”部分，可以看到连接到计算机的移动设备，点击“inspect”按钮即可映射移动设备上的 Webview 视图到 Chrome 开发者工具中。</p></li></ol><p>这种映射的原理是通过 Chrome 远程调试协议来实现的。移动设备上的 Webview 实际上是一个嵌入在应用程序中的浏览器视图，Chrome 开发者工具通过远程调试协议来与该视图进行通信，并将调试信息返回给开发者工具界面。这样，开发者就可以在计算机上通过 Chrome 开发者工具来调试移动设备上的 Web 应用程序了。<br>具体的映射关系如下所示</p><img src="/2023/03/16/DevTools/%E5%9F%BA%E4%BA%8EADB%E7%9A%84%E8%B0%83%E8%AF%95%E6%B5%81%E7%A8%8B.png" class="" title="基于ADB的调试流程"><h3 id="Chrome-Inspect如何实现webview视图和Chrome开发者工具交互"><a href="#Chrome-Inspect如何实现webview视图和Chrome开发者工具交互" class="headerlink" title="Chrome Inspect如何实现webview视图和Chrome开发者工具交互"></a>Chrome Inspect如何实现webview视图和Chrome开发者工具交互</h3><p>从上述的知识可以知道，因为移动设备的webview页面被转发到PC的对应端口，通过 Chrome 远程调试协议操纵 Chrome 开发者工具面板就可以操纵Android&#x2F;iOS 移动设备 WebView 视图。</p><h3 id="chrome和webview的架构图"><a href="#chrome和webview的架构图" class="headerlink" title="chrome和webview的架构图"></a>chrome和webview的架构图</h3><img src="/2023/03/16/DevTools/%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%9F%E7%90%86.png" class="" title="程序调试小程序原理">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序架构</title>
    <link href="/2023/03/10/miniAPP-1/"/>
    <url>/2023/03/10/miniAPP-1/</url>
    
    <content type="html"><![CDATA[<h1 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h1><h2 id="1-小程序项目结构文件"><a href="#1-小程序项目结构文件" class="headerlink" title="1. 小程序项目结构文件"></a>1. 小程序项目结构文件</h2><img src="/2023/03/10/miniAPP-1/file.png" class="" title="项目架构图片"><ol><li>app.js：小程序的入口文件，主要包含了小程序的生命周期函数、全局变量和全局函数等。</li><li>app.json：小程序的全局配置文件，包含了小程序的基本信息、页面路径、窗口配置、导航栏配置等。</li><li>app.wxss：小程序的全局样式文件，包含了小程序的全局样式定义。</li><li>pages：小程序的页面目录，包含了小程序所有的页面文件，每个页面通常由一个.wxml、.js、.wxss和.json文件组成。</li></ol><h3 id="1-1-JSON文件"><a href="#1-1-JSON文件" class="headerlink" title="1.1. JSON文件"></a>1.1. JSON文件</h3><ol><li>页面路由配置：在这个文件中，可以配置当前页面的路由信息，包括页面的路径、页面的名称、页面展示的位置等。在小程序中，每个页面都需要配置对应的路由信息才能够被正确访问。</li><li>窗口配置：在这个文件中，可以配置当前页面的窗口相关的信息，包括导航栏颜色、背景色、是否开启下拉刷新等。通过这个文件，可以对页面的显示效果进行定制。</li><li>生命周期配置：在这个文件中，可以配置当前页面的生命周期相关的信息，包括页面加载、页面显示、页面隐藏、页面卸载等。通过这个文件，可以控制页面在不同的生命周期中执行不同的操作。</li><li>页面配置：在这个文件中，可以配置当前页面的一些基本信息，包括页面标题、页面是否允许分享等。通过这个文件，可以控制页面的基本行为。</li></ol><h3 id="1-2-WXML文件"><a href="#1-2-WXML文件" class="headerlink" title="1.2. WXML文件"></a>1.2. WXML文件</h3><ol><li>定义页面结构：在这个文件中，可以定义当前页面的结构信息，包括HTML标签、CSS样式、文本等。通过这个文件，可以控制页面的布局和显示效果。</li><li>绑定数据和事件：在这个文件中，可以绑定当前页面中所需要的数据和事件。通过这个文件，可以将页面的数据和业务逻辑与视图进行分离，提高代码的可维护性。</li><li>嵌套其他组件：在这个文件中，可以嵌套其他小程序组件，比如按钮、图片、表单等。通过这个文件，可以实现复杂的页面布局和交互效果。</li></ol><h3 id="1-3-WXSS文件"><a href="#1-3-WXSS文件" class="headerlink" title="1.3. WXSS文件"></a>1.3. WXSS文件</h3><ol><li>定义页面样式：在这个文件中，可以定义当前页面的样式信息，包括文字大小、颜色、背景色、边框、布局等。通过这个文件，可以控制页面的显示效果，使页面更加美观、易读。</li><li>支持继承和覆盖：在这个文件中，可以继承和覆盖其他样式，使样式表更加简洁和易于维护。</li><li>适配不同设备：在这个文件中，可以根据设备屏幕大小和分辨率等不同特点，制定不同的样式规则，使页面在不同设备上的显示效果更加一致和合适。</li></ol><h3 id="1-4-JavaScript文件"><a href="#1-4-JavaScript文件" class="headerlink" title="1.4. JavaScript文件"></a>1.4. JavaScript文件</h3><ol><li>控制页面行为：在这个文件中，可以编写当前页面的业务逻辑，包括数据的获取、处理、显示、提交等。通过这个文件，可以控制页面的行为，实现页面的动态效果和交互逻辑。</li><li>调用小程序API：在这个文件中，可以调用小程序提供的API接口，实现不同的功能和服务，比如获取用户信息、获取设备信息、调用微信支付等。</li><li>引入其他文件：在这个文件中，可以引入其他JavaScript文件、JSON文件、WXML文件和WXSS文件，以实现页面的复杂功能和逻辑。</li></ol><h2 id="2-小程序宿主环境"><a href="#2-小程序宿主环境" class="headerlink" title="2. 小程序宿主环境"></a>2. 小程序宿主环境</h2><p>小程序的运行环境分成渲染层和逻辑层，WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。</p><h3 id="2-1-通信模型"><a href="#2-1-通信模型" class="headerlink" title="2.1. 通信模型"></a>2.1. 通信模型</h3><p>微信小程序的渲染层和逻辑层是分离的，它们之间通过微信客户端进行通信。该通信模型包含了三个部分：渲染层、逻辑层和微信客户端。</p><ol><li>渲染层：渲染层负责小程序的页面渲染，包括 WXML 模板的解析、样式的计算和渲染等。渲染层不涉及具体业务逻辑，只负责页面的展示。</li><li>逻辑层：逻辑层负责小程序的业务逻辑处理，包括数据的处理和交互行为的响应等。逻辑层与渲染层相对独立，可以通过数据绑定和事件等方式与渲染层进行通信。</li><li>微信客户端：通信模块负责实现渲染层和逻辑层之间的通信，包括事件的发送和接收、数据的传递等。</li></ol><p>在这个通信模型中，逻辑层可以通过 setData 方法向渲染层发送数据，渲染层可以通过 WXML 模板和 WXSS 样式表展示数据和样式，同时，渲染层也可以通过事件传递给逻辑层用户的交互行为。逻辑层可以通过事件监听函数响应这些事件，执行相应的业务逻辑处理。</p><img src="/2023/03/10/miniAPP-1/%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png" class="" title="通信模型图片"><h3 id="2-2-数据驱动"><a href="#2-2-数据驱动" class="headerlink" title="2.2. 数据驱动"></a>2.2. 数据驱动</h3><p>微信小程序采用的是数据驱动的开发模式，即通过数据来驱动页面的渲染和交互。其原理是通过数据绑定的方式将数据与页面元素进行关联，当数据发生变化时，页面会自动更新，从而实现了动态的页面渲染和交互。<br>而数据驱动的原理：WXML结构实际上等价于一棵Dom树，通过一个JS对象也可以来表达Dom树的结构，WXML可以先转成JS对象，然后再渲染出真正的Dom树。</p><img src="/2023/03/10/miniAPP-1/%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8-1.png" class="" title="转化图片"><ol><li>数据绑定：微信小程序支持数据绑定，即可以将数据与页面元素进行绑定，从而在数据发生变化时，自动更新页面。开发者可以通过在 WXML 模板中使用 <code>&#123;&#123; &#125;&#125;</code> 语法将数据绑定到页面元素上，比如将一个变量绑定到文本框的值上。</li><li>数据监听：微信小程序中的数据变化是通过数据监听来实现的，即当数据发生变化时，会触发相应的事件。开发者可以通过监听数据变化的事件来实现页面的动态更新。</li><li>数据更新：微信小程序的数据更新是自动的，当数据发生变化时，页面会自动更新，无需手动进行刷新。开发者只需要在逻辑层修改数据，页面就会自动更新。</li><li>双向绑定：微信小程序还支持双向绑定，即当页面元素的值发生变化时，会自动更新关联的数据。开发者可以通过使用双向绑定来简化代码的编写，提高开发效率。</li></ol><p>同时可以对比前后两个JS对象得到变化的部分，然后把这个差异应用到原来的Dom树上，从而达到快速更新UI的目的。</p><img src="/2023/03/10/miniAPP-1/%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8.png" class="" title="转化图片"><h3 id="2-3-页面渲染"><a href="#2-3-页面渲染" class="headerlink" title="2.3. 页面渲染"></a>2.3. 页面渲染</h3><p>上述的数据驱动可以知道小程序的页面渲染的流程。小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。</p><img src="/2023/03/10/miniAPP-1/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93.png" class="" title="渲染图片"><h2 id="3-小程序底层架构"><a href="#3-小程序底层架构" class="headerlink" title="3. 小程序底层架构"></a>3. 小程序底层架构</h2><p>上文所述：整个小程序系统构架分成两个部分：视图层(WebView) 和 逻辑层(App Service)，这两个部分分别由两个独立线程管理。</p><h3 id="3-1-通信原理"><a href="#3-1-通信原理" class="headerlink" title="3.1. 通信原理"></a>3.1. 通信原理</h3><h4 id="3-1-1-视图层"><a href="#3-1-1-视图层" class="headerlink" title="3.1.1. 视图层"></a>3.1.1. 视图层</h4><p>在微信小程序中，视图层与客户端之间的通信主要是通过 WeiXinJSBridge 这个兼容层来实现的。</p><p>当开发者插入一个原生组件时，组件运行的时候会被插入到 DOM 树中，同时也会调用客户端接口，通知客户端在哪个位置渲染原生界面。当开发者更新组件属性时，同样也会调用客户端提供的更新接口来更新原生界面的某些部分。</p><p>在 iOS 中，视图层与客户端的通信是利用 WKWebView 提供的 messageHandlers 特性来实现的。开发者可以通过调用 window.webkit.messageHandlers.方法名.postMessage(参数) 来向客户端发送消息，客户端可以通过设置 messageHandlers.方法名 的处理函数来接收并处理这些消息。</p><p>在安卓中，视图层与客户端的通信是通过往 WebView 的 window 对象注入一个原生方法来实现的。开发者可以通过调用 window.WeixinJSBridge.invoke(方法名, 参数, 回调函数) 来向客户端发送消息，客户端可以通过设置 WeixinJSBridge.on(‘方法名’, 处理函数) 来接收并处理这些消息。</p><p>无论是在 iOS 还是安卓中，WeiXinJSBridge 兼容层都起到了桥接视图层和客户端之间通信的作用。视图层只需要调用 WeiXinJSBridge 提供的接口，然后 WeiXinJSBridge 会将消息传递给客户端，并将客户端的处理结果再传递回视图层。这样就实现了视图层和客户端之间的通信。</p><h4 id="3-1-2-逻辑层"><a href="#3-1-2-逻辑层" class="headerlink" title="3.1.2. 逻辑层"></a>3.1.2. 逻辑层</h4><p>逻辑层与客户端原生通信机制与渲染层类似，不同在于，iOS平台可以往JavaScripCore框架注入一个全局的原生方法，而安卓方面则是跟渲染层一致的。</p><p>同样地，开发者也是间接地调用到与客户端原生通信的底层接口。一般我们会对逻辑层接口做层封装后才暴露给开发者，封装的细节可能是统一入参、做些参数校验、兼容各平台或版本问题等等。</p><h3 id="3-2-数据通信"><a href="#3-2-数据通信" class="headerlink" title="3.2. 数据通信"></a>3.2. 数据通信</h3><p>小程序是基于双线程模型，那就意味着任何数据传递都是线程间的通信，也就是都会有一定的延时。这不像传统Web那样，当界面需要更新时，通过调用更新接口UI就会同步地渲染出来。在小程序架构里，这一切都会变成异步。<br>异步会使得各部分的运行时序变得复杂一些。比如在渲染首屏的时候，逻辑层与渲染层会同时开始初始化工作，但是渲染层需要有逻辑层的数据才能把界面渲染出来，如果渲染层初始化工作较快完成，就要等逻辑层的指令才能进行下一步工作。因此逻辑层与渲染层需要有一定的机制保证时序正确，<br>在每个小程序页面的生命周期中，存在着若干次页面数据通信。逻辑层向视图层发送页面数据（data和setData的内容），视图层向逻辑层反馈用户事件。</p><img src="/2023/03/10/miniAPP-1/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1-%E5%8E%9F%E7%90%86.png" class="" title="数据通信"><h3 id="3-3-视图层渲染"><a href="#3-3-视图层渲染" class="headerlink" title="3.3. 视图层渲染"></a>3.3. 视图层渲染</h3><p>视图层在接收到初始数据（data）和更新数据（setData数据）时，需要进行视图层渲染。在一个页面的生命周期中，视图层会收到一份初始数据和多份更新数据。收到初始数据时需要执行初始渲染，每次收到更新数据时需要执行重渲染。</p><p>初始渲染发生在页面刚刚创建时。初始渲染时，将初始数据套用在对应的WXML片段上生成节点树。节点树也就是在开发者工具WXML面板中看到的页面树结构，它包含页面内所有组件节点的名称、属性值和事件回调函数等信息。最后根据节点树包含的各个节点，在界面上依次创建出各个组件。</p><p>初始渲染完毕后，视图层可以多次应用setData的数据。每次应用setData数据时，都会执行重渲染来更新界面。<br>初始渲染中得到的data和当前节点树会保留下来用于重渲染。每次重渲染时，将data和setData数据套用在WXML片段上，得到一个新节点树。然后将新节点树与当前节点树进行比较，这样可以得到哪些节点的哪些属性需要更新、哪些节点需要添加或移除。最后，将setData数据合并到data中，并用新节点树替换旧节点树，用于下一次重渲染。</p><img src="/2023/03/10/miniAPP-1/%E8%A7%86%E5%9B%BE%E6%B8%B2%E6%9F%93.png" class="" title="视图渲染">]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Caddy简介与使用指南</title>
    <link href="/2023/03/07/caddy/"/>
    <url>/2023/03/07/caddy/</url>
    
    <content type="html"><![CDATA[<p>Caddy是一个快速、现代化且易于使用的Web服务器，它支持自动化的HTTPS，可轻松配置反向代理和静态文件服务等功能。Caddy是一款基于Go语言开发的服务器，适用于多种操作系统，包括Linux、Mac和Windows等。本文将介绍Caddy在Ubuntu下的安装及常用功能的使用指南。</p><p>官方文档： <a href="https://caddyserver.com/docs/">Caddy官方地址</a>。</p><h2 id="1-安装Caddy"><a href="#1-安装Caddy" class="headerlink" title="1. 安装Caddy"></a>1. 安装Caddy</h2><p><strong>Ubuntu安装</strong></p><pre><code class="hljs">sudo apt install -y debian-keyring debian-archive-keyring apt-transport-httpscurl -1sLf &#39;https://dl.cloudsmith.io/public/caddy/stable/gpg.key&#39; | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpgcurl -1sLf &#39;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt&#39; | sudo tee /etc/apt/sources.list.d/caddy-stable.listsudo apt updatesudo apt install caddy</code></pre><h2 id="2-Caddy的两种启动方式"><a href="#2-Caddy的两种启动方式" class="headerlink" title="2. Caddy的两种启动方式"></a>2. Caddy的两种启动方式</h2><p>Caddy有两种启动方式：使用JSON格式的配置文件和使用Caddyfile。下面将分别介绍它们的优缺点和使用方法。</p><h3 id="2-1-使用JSON格式的配置文件启动Caddy"><a href="#2-1-使用JSON格式的配置文件启动Caddy" class="headerlink" title="2.1 使用JSON格式的配置文件启动Caddy"></a>2.1 使用JSON格式的配置文件启动Caddy</h3><p>首先写一个Json文件，保存为caddy.json</p><pre><code class="hljs">    &#123;        &quot;apps&quot;: &#123;            &quot;http&quot;: &#123;                &quot;servers&quot;: &#123;                    &quot;example&quot;: &#123;                        &quot;listen&quot;: [&quot;:2015&quot;],                        &quot;routes&quot;: [                            &#123;                                &quot;handle&quot;: [&#123;                                    &quot;handler&quot;: &quot;static_response&quot;,                                    &quot;body&quot;: &quot;Hello, world!&quot;                                &#125;]                            &#125;                        ]                    &#125;                &#125;            &#125;        &#125;    &#125;</code></pre><p>上传json文件</p><pre><code class="hljs">    curl localhost:2019/load \    -H &quot;Content-Type: application/json&quot; \    -d @caddy.json</code></pre><p>使用JSON格式的配置文件的优点是灵活性高，可以通过配置文件实现更复杂的设置。缺点是配置文件语法相对复杂，需要一定的学习成本。</p><h3 id="2-2-使用Caddyfile启动Caddy"><a href="#2-2-使用Caddyfile启动Caddy" class="headerlink" title="2.2 使用Caddyfile启动Caddy"></a>2.2 使用Caddyfile启动Caddy</h3><p>使用Caddyfile启动Caddy非常简单，只需要在命令行中指定要监听的地址和要处理的站点即可。Caddyfile语法类似于Apache的配置文件，易于学习和使用。以下是一个简单的Caddyfile示例：</p><pre><code class="hljs">    :2015    respond &quot;Hello, world!&quot;</code></pre><p>启动caddy</p><pre><code class="hljs">    caddy run --config /path/to/Caddyfile</code></pre><h2 id="3-两种启动方式的优劣对比"><a href="#3-两种启动方式的优劣对比" class="headerlink" title="3. 两种启动方式的优劣对比"></a>3. 两种启动方式的优劣对比</h2><p>使用Caddyfile启动Caddy非常方便，语法简单易懂，适合快速设置和调试。而使用JSON格式的配置文件可以更好地处理复杂的设置，可以编写脚本自动生成配置文件等。</p><p>对于初学者来说，建议使用Caddyfile启动Caddy，等熟悉了Caddy的基本功能后再尝试使用JSON格式的配置文件。</p><img src="/2023/03/07/caddy/jsonVSfile.png" class="" title="对比图片"><h2 id="4-API和Config-files的配置"><a href="#4-API和Config-files的配置" class="headerlink" title="4. API和Config files的配置"></a>4. API和Config files的配置</h2><p>API方式通过HTTP请求实现配置更改，可以使用多种编程语言进行交互，并可以实时更改配置。使用API的优点是灵活性高，可以通过程序化方式自动化配置更改，但需要一定的编程知识。此外，API方式易于扩展和集成到自己的工作流中。</p><p>配置文件方式通过CLI命令实现配置更改，使用模板语言进行更高级的操作，如自动化证书管理、路由控制等。配置文件易于理解、共享和备份，可以方便地手动修改。但使用配置文件的缺点是不便于扩展和自动化管理，并且需要一定的命令行使用知识。</p><p>在选择API或配置文件方式时，需要考虑自己的工作流程和需求。API方式适合于需要高度灵活性和自动化管理的场景，而配置文件方式适合于手动管理、易于理解的场景。同时，也可以根据实际需求选择使用JSON或Caddyfile作为配置文件格式。</p><h2 id="5-Caddy反向代理的实现步骤"><a href="#5-Caddy反向代理的实现步骤" class="headerlink" title="5. Caddy反向代理的实现步骤"></a>5. Caddy反向代理的实现步骤</h2><p>Caddy支持反向代理功能，可以将请求转发到其他服务器或服务。以下是实现反向代理的步骤：</p><p>编写Caddyfile或JSON格式的配置文件，指定要反向代理的地址和要代理的站点。<br>启动Caddy，等待代理生效。比如下面的代码就将9000代理到2080。</p><pre><code class="hljs">caddy reverse-proxy --from :2080 --to :9000</code></pre><h2 id="6-Caddy实现HTTPS代理的步骤"><a href="#6-Caddy实现HTTPS代理的步骤" class="headerlink" title="6. Caddy实现HTTPS代理的步骤"></a>6. Caddy实现HTTPS代理的步骤</h2><p>简单的 HTTPS 反向代理命令，实现访问<a href="https://www.example.com/">https://www.example.com</a> -&gt; localhost:9000</p><pre><code class="hljs">caddy reverse-proxy --from example.com --to localhost:9000</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/07/hello-world/"/>
    <url>/2023/03/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><hr><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
